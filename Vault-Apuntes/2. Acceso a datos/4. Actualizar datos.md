Para actualizar datos, lo que haremos será **cargar los datos del cliente a la UI** y actualizarlos todos en la BBDD, aunque el usuario no los haya cambiado. 

![[explicacion update.canvas|explicacion update]]
	(click en la imagen)

### Obtener los datos en formato diccionario
---

```python
@staticmethod  
def datosCliente(dni):  
    # Creamos un diccionario, que sera el return  
    result = []  
  
    # Preparar query  
    query = QtSql.QSqlQuery()  
    query.prepare("SELECT * FROM clientes WHERE dni=:dni")  
    query.bindValue(':dni', str(dni))  
  
    if query.exec():  
        if query.next():  
            # Cada fila tiene 8 elementos, 7 sin contar el ID (elemento 0)  
            elemento = 1  # Empezariamos en el elemento 1 (dni)
            while elemento<=7:  
                result.append(query.value(elemento))  
                elemento += 1  
        else:  
            print("[+] Cliente no existe")  
    else:  
        print("[!] No se pudo ejecutar la query")  
  
    print("Resultado de datos cliente: ", result)  
    return result
```

El resultado de ejecutar esta función debería ser algo así:
```
['11111111H', 'Gómez Rodríguez', 'Lucía', 'A Coruña', 'Mujer', '05/01/2024', "['Transferencia']"]
```

### Cargar todos los datos del cliente a UI
---
Antes solamente cargaba el DNI, Apellidos y nombre, pero con este refactor lo puede cargar todo. También es importante resaltar **almacenar el DNI del cliente** que se carga, por si se modifica poder poner el WHERE en sql despues.

```python
    def cargarCliente():
        try:
            # Antes de cargar nada limpiamos todos los campos para evitar errores
            Customers.limpiarCliente()
            # Cargamos a la variable fila los valores de la fila seleccionada de la tabla
            # !! Esta fila es una lista de objetos tipo QTableWidgetItem, no de strings
            fila = var.ui.tablaClientes.selectedItems()
            if fila: # Si la fila no está vacía...
                # Extraemos el texto de cada objeto del diccionario
                fila = [dato.text() for dato in fila]
            # Imprimimos la fila para ver que to esté bien
            print(fila)
            # La columna 0 es siempre el DNI
            dni = fila[0]
            # IMPORTANTE guardamos el oldDni para actualizar los otros datos  
			var.oldDni = dni
            # Llamamos a la BBDD para que consulte los datos del cliente por su DNI
            datosCliente = conexion.Conexion.datosCliente(dni)

            # Asignar a cada campos su valor
            var.ui.txtDniCli.setText(str(datosCliente[0]))
            var.ui.txtApelidosCli.setText(str(datosCliente[1]))
            var.ui.txtNombreCli.setText(str(datosCliente[2]))
            var.ui.comboBoxProvincias.setCurrentText(str(datosCliente[3]))
            if (datosCliente[4] == "Mujer"):
                var.ui.rbtMujer.setChecked(True)
            else:
                var.ui.rbtHombre.setChecked(True)
            var.ui.txtFecha.setText(str(datosCliente[5]))
            pagos = datosCliente[6]
            if 'Transferencia' in pagos:
                var.ui.cbTransferencia.setChecked(True)
            if 'Efectivo' in pagos:
                var.ui.cbEfectivo.setChecked(True)
            if 'Tarjeta' in pagos:
                var.ui.cbTarjeta.setChecked(True)


        except Exception as e:
            print("Error ", e)
```

### Actualizar registro en la BBDD
---
En la clase **Conexion**, creamos un metodo update (``actualizaCliente()``), que reciba como parametro un cliente en formato diccionario (**esto lo conseguimos con el metodo datosCliente()**) y que tenga en cuenta el oldDni para actualizar el dato.

```python
    @staticmethod
    def actualizaCliente(cliente):
        query = QtSql.QSqlQuery()
        # Preparamos la query
        query.prepare("UPDATE clientes SET "
                      "dni = :dni, "
                      "apellidos = :apellidos, "
                      "nombre = :nombre, "
                      "fechaalta = :fechaalta, "
                      "provincia = :provincia, "
                      "sexo = :sexo, "
                      "formaspago = :formaspago "
                      "WHERE dni = :oldDni")
        # Sustituimos los valores con bindValue() para evitar SQLi
        query.bindValue(':dni', str(cliente[0]))
        query.bindValue(':apellidos', str(cliente[1]))
        query.bindValue(':nombre', str(cliente[2]))
        query.bindValue(':fechaalta', str(cliente[3]))
        query.bindValue(':provincia', str(cliente[4]))
        query.bindValue(':sexo', str(cliente[5]))
        query.bindValue(':formaspago', str(cliente[6]))
        query.bindValue(':oldDni', var.oldDni)

        if query.exec():
            print("[+] Actualizacion correcta de ", cliente)
            Conexion.cargarClientesTabla()
        else:
            print("Error ", query.lastError().text())
```

### Asignacion del botón
---
Creamos la función en clientes.Customers, que **recibe los datos de la interfaz**, los formatea y se los pasa a **actualizaCliente** para que pueda hacer la actualizacion.

```python
def modificaCliente():  
    cliente = Customers.datosCliente()  
    conexion.Conexion.actualizaCliente(cliente)
```

Codificamos que el botón de modificar ejecute esa acción

```python
# Conectado boton actualizar con su funcion  
var.ui.botModificar.clicked.connect(clients.Customers.modificaCliente)
```